# Анализ Современных Систем Миграций БД

## Лучшие Инструменты Миграций 2025-2026

### Flyway
**Ориентация:** Разработчики, SQL-first подход
**Поддержка:** 22+ SQL БД + MongoDB (preview)

**Принципы:**
- Императивный подход: миграции как последовательность SQL-скриптов
- Линейная версионность: файлы V1, V2, V3... выполняются строго по порядку
- Минимализм: простая настройка, быстрое выполнение
- Формат конфигурации: flyway.toml (2025)
- Визуализация: Flyway Desktop с Schema Model view и Git history

**Когда использовать:**
- Проект под одну БД
- Команда комфортно работает с чистым SQL
- Приоритет простоты над гибкостью

### Liquibase
**Ориентация:** Enterprise, database-agnostic
**Поддержка:** Мультиплатформенность

**Принципы:**
- Декларативный подход: ChangeLog как артефакт развертывания
- Формат: XML, YAML, JSON, SQL
- Гибкость порядка: изменения могут переупорядочиваться
- Абстракция БД: один changeset генерирует SQL для разных СУБД
- Расширенные возможности: preconditions, контекстные развертывания
- Flow-оркестрация: сложные сценарии деплоя (2025)
- Python Custom Policy Checks для Pro версии

**Когда использовать:**
- Мультиплатформенное приложение
- Нужны встроенные rollback
- Требуется детальный контроль развертывания
- Регулируемые индустрии с требованиями к аудиту

### Alembic
**Ориентация:** Python + SQLAlchemy экосистема

**Принципы:**
- ORM-based миграции на Python
- Тесная интеграция с SQLAlchemy
- Python-скриптинг для сложной логики
- Поддержка чистого SQL при необходимости

**Когда использовать:**
- Python-проекты с SQLAlchemy
- Нужна интеграция с Python-экосистемой

### Doctrine Migrations
**Ориентация:** PHP + Doctrine ORM

**Принципы:**
- ORM-based подход для PHP
- Похожие паттерны на Alembic для PHP-мира

---

## Механизмы Обеспечения Порядка Миграций

### Flyway: Линейная Версионность

**1. Файловая Система как Источник Истины**
- Имена файлов задают порядок: `V1__init.sql`, `V2__add_users.sql`, `V2.1__add_index.sql`
- Числовая сортировка версий (не лексикографическая)
- Формат: `V{version}__{description}.sql`
- Поддержка десятичных версий для вставок: V2.1, V2.2 между V2 и V3

**2. Schema History Table: flyway_schema_history**
Таблица аудита всех примененных миграций:
```
installed_rank  | version | description      | type | script                | checksum    | installed_by | installed_on        | execution_time | success
1               | 1       | init             | SQL  | V1__init.sql         | 1234567890  | admin        | 2025-01-10 10:00:00 | 120           | true
2               | 2       | add users        | SQL  | V2__add_users.sql    | 9876543210  | admin        | 2025-01-11 11:00:00 | 450           | true
```

**3. Алгоритм Выполнения**
```
1. Сканирование директории миграций
2. Сортировка файлов по version (числовая)
3. Чтение flyway_schema_history из БД
4. Сравнение: version из файла vs version в истории
5. Если version <= current_version → SKIP (уже применена)
6. Если version > current_version → PENDING (к выполнению)
7. Выполнение PENDING миграций по порядку version
8. После успеха: INSERT в flyway_schema_history
```

**4. Checksum Validation**
- При запуске: пересчет checksum для всех примененных миграций
- Сравнение с checksum в flyway_schema_history
- Если не совпадает → ERROR (файл изменен после применения)
- Защита от случайных изменений истории
- Hash-функция на весь контент файла

**5. Гарантии Порядка**
- **Строгая линейность:** невозможно вставить миграцию с version < current
- **Gap detection:** пропуски в версиях (V1, V3 без V2) вызывают ошибку
- **Immutability:** примененные миграции нельзя менять (checksum защита)

### Liquibase: Артефактная Версионность

**1. ChangeLog как Источник Истины**
- XML/YAML/JSON файлы с набором changesets
- Каждый changeset имеет уникальный идентификатор: `id + author + filepath`
- Порядок в файле ≠ обязательный порядок выполнения

**2. DATABASECHANGELOG Tracking Table**
```
ID          | AUTHOR | FILENAME           | DATEEXECUTED        | ORDEREXECUTED | EXECTYPE | MD5SUM              | DESCRIPTION
init-001    | dev1   | changelog-1.0.xml | 2025-01-10 10:00:00 | 1             | EXECUTED | abc123...           | createTable users
add-col-001 | dev2   | changelog-1.1.xml | 2025-01-11 11:00:00 | 2             | EXECUTED | def456...           | addColumn email
```

**3. Уникальная Идентификация Changeset**
- **Composite Key:** `id + author + filepath` = уникальный changeset
- Не номер версии, а логический идентификатор
- `id` может быть любым (строка, не обязательно число)
- Позволяет параллельную разработку без конфликтов

**4. Алгоритм Выполнения**
```
1. Парсинг changelog файла (порядок чтения = порядок в файле)
2. Чтение DATABASECHANGELOG из БД
3. Для каждого changeset:
   - Проверка: есть ли (id+author+filepath) в DATABASECHANGELOG?
   - Если НЕТ → PENDING (preconditions check)
   - Если ДА → SKIP
4. Проверка preconditions для PENDING changesets
5. Выполнение PENDING changesets в порядке появления в changelog
6. После успеха: INSERT в DATABASECHANGELOG с ORDEREXECUTED (sequence)
```

**5. runOrder Attribute**
Переопределение порядка выполнения:
- `runOrder="first"` - выполнить перед всеми остальными
- `runOrder="last"` - выполнить после всех
- Без атрибута - последовательный порядок по changelog

**6. MD5SUM Checksum Validation**
- При каждом запуске: пересчет MD5 hash changeset'а
- Сравнение с MD5SUM в DATABASECHANGELOG
- Если изменен → WARNING или ERROR (зависит от конфига)
- Можно обновить checksum через `liquibase clearCheckSums`

**7. Гибкость Порядка**
- **Переупорядочивание:** можно менять последовательность changesets в файле
- **Вставки:** новый changeset с любым id можно вставить где угодно
- **Параллельная разработка:** разные авторы создают changesets без конфликтов
- **ORDEREXECUTED:** реальный порядок выполнения фиксируется в БД

**8. Rollback Tracking**
- DATEEXECUTED сохраняет timestamp выполнения
- Для rollback используется ORDEREXECUTED (порядковый номер)
- `rollback count 3` откатывает последние 3 changeset'а по ORDEREXECUTED

### Общие Механизмы

**1. Transaction Management**
- Каждая миграция в транзакции (где поддерживается СУБД)
- COMMIT только после успешного выполнения
- ROLLBACK при ошибке → миграция не записывается в tracking table

**2. Locking Mechanism**
- Pessimistic lock на tracking table при запуске
- Предотвращает одновременное выполнение миграций
- Защита от race conditions в кластерных деплоях

**3. Baseline**
- Установка начальной точки для существующих БД
- Flyway: `baseline` версия как стартовая
- Liquibase: пометка changesets как уже выполненных

**4. Validation Modes**
- **Strict:** любое несоответствие = ошибка
- **Lenient:** предупреждения вместо ошибок
- **Skip:** игнорировать проблемы (опасно)

### Сравнение Подходов

| Аспект | Flyway | Liquibase |
|--------|--------|-----------|
| **Идентификация** | Числовая версия | id+author+filepath |
| **Порядок** | Жесткий (version order) | Гибкий (файл order + runOrder) |
| **Вставки** | Только через .1, .2 суффиксы | Любой новый id в любом месте |
| **Конфликты** | Высокий риск при параллельной работе | Низкий риск (разные id/author) |
| **Простота** | Очень простая (номер = порядок) | Сложнее (composite key) |
| **Аудит** | installed_rank + version | ORDEREXECUTED + composite key |
| **Checksum** | CRC32 весь файл | MD5 содержимого changeset |
| **Rollback** | По version (платно) | По ORDEREXECUTED (встроено) |

### Критичные Детали

**Flyway Gaps:**
- Gap detection по умолчанию ON
- V1, V3 без V2 = ERROR
- Защита от пропущенных миграций

**Liquibase Preconditions:**
- Условия выполнения changeset
- Проверка наличия таблиц, колонок
- Пропуск если условия не выполнены

**Checksum Mismatches:**
- Flyway: строгая ошибка, требует repair
- Liquibase: warning или error (настраивается)

**Concurrent Execution:**
- Оба используют database-level locks
- Первый процесс получает lock, остальные ждут
- Timeout для lock acquisition

---

## Фундаментальные Принципы Современных Миграций

### 1. Version Control Integration
**Принцип:** Миграции как код
- Каждая миграция = один файл = одна логическая единица изменений
- Хранение в VCS рядом с кодом приложения
- CI/CD интеграция: автоматический запуск в pipeline
- История изменений схемы = Git history

### 2. Атомарность и Идемпотентность
**Атомарность:**
- Одна миграция = одно логическое изменение
- Транзакционное выполнение где возможно
- Fail-fast при ошибках

**Идемпотентность:**
- Безопасное повторное выполнение
- Проверки существования объектов (IF NOT EXISTS)
- Deterministic результаты

### 3. Линейная vs Артефактная Версионность

**Линейная (Flyway):**
- Жесткий порядок: V1 → V2 → V3
- Простота понимания
- Конфликты при параллельной разработке

**Артефактная (Liquibase):**
- Гибкий порядок выполнения
- Переупорядочивание changesets
- Лучше для команд
- Сложнее в понимании

### 4. State-Based vs Migration-Based

**Migration-Based (доминирующий подход):**
- Explicit изменения в скриптах
- Полный контроль
- История изменений видна явно
- Требует дисциплины

**State-Based:**
- Описание желаемого состояния
- Инструмент генерирует diff
- Риск непредсказуемых изменений
- Меньше используется в продакшене

---

## Паттерны Zero-Downtime Миграций

### 1. Expand-Contract Pattern (Parallel Change)
**Самый надежный паттерн для сложных изменений**

**Фазы:**
1. **Expand:** Добавление новых структур параллельно старым
   - Новые колонки, таблицы, индексы
   - Приложение пишет в обе структуры одновременно

2. **Migrate:** Фоновая миграция данных
   - Batch-обработка исторических данных
   - Минимальная нагрузка на БД

3. **Contract:** Удаление старых структур
   - Только после подтверждения нулевых зависимостей
   - Ожидание минимум одного полного цикла деплоя

**Ключевой принцип:** Разбиение опасных изменений на безопасные инкрементальные шаги

### 2. Backward Compatibility Principle
**Мандат для zero-downtime**

**Правило:** Каждая миграция совместима с текущей версией приложения
- Миграция выполняется при работающей старой версии приложения
- Новый код деплоится только после завершения миграции
- Разделение деплоя БД и приложения

**Техники:**
- Новые колонки: nullable или с default значениями
- Не удалять то, что использует текущий код
- Избегать breaking changes в схеме

### 3. Blue-Green Database Deployment
**Две идентичных среды**

**Принципы:**
- Трафик на одну среду (blue), обновление другой (green)
- Тестирование на green перед переключением
- Атомарное переключение трафика
- Быстрый rollback через обратное переключение

**Реальность для БД:**
- Больше mandate "no breaking changes", чем технического решения
- БД слишком большие для полного копирования на каждый деплой
- Требует backward compatibility
- Удвоение capacity = увеличение стоимости

**Execution:**
- Миграции выполняются как отдельный шаг перед деплоем кода
- Схема готова для нового кода, но совместима со старым

### 4. Change Data Capture (CDC) Pattern
**Для сложных миграций систем**

**Принципы:**
- Двунаправленная репликация между legacy и target системами
- Enterprise CDC инструменты: Oracle GoldenGate, AWS DMS, Confluent Connect
- Обработка schema evolution, data type transformations
- Conflict resolution с минимальной latency
- Постепенный переход без остановки системы

### 5. Feature Flags для Контроля Миграций
**Kill switch для схемы**

**Принципы:**
- Контроль rollout через feature flags
- Быстрый откат без revert миграций
- Постепенное включение новой схемы
- A/B тестирование схемных изменений

---

## Rollback и Safety Стратегии

### 1. Backup-First Principle
**Ultima ratio rollback**
- Полный verified backup перед любой миграцией
- Минимум два изолированных хранилища
- Одно off-site или в другом cloud region
- Регулярное тестирование восстановления

### 2. Explicit Rollback Scripts
**Liquibase подход:**
- Специальное поле в changeset для rollback SQL
- Автоматическая генерация для простых операций
- Explicit определение для сложных изменений

**Flyway подход:**
- Платная функция в Teams/Enterprise
- Отдельные файлы undo-миграций

### 3. Rollback Triggers
**Автоматизация решения об откате**

**Условия:**
- Превышение порога ошибок валидации данных
- Критическая функциональность не работает
- Неприемлемая деградация производительности
- Мониторинг и алерты триггерят автооткат

### 4. Progressive Rollback Plan
**Документированный процесс**
- Step-by-step инструкции
- Кто контактирует, какие инструменты использовать
- Expected time to recovery
- Тестирование процедуры отката
- Понятно для любого квалифицированного члена команды

---

## Best Practices 2025

### Testing Strategy
**Multi-layer валидация:**
1. QA/Staging тестирование перед продакшеном
2. Автотесты на совместимость старой и новой версии приложения
3. Интеграционные тесты миграций в CI/CD
4. Production-like данные в тестовых средах

### Phased (Trickle) Migration
**Инкрементальный подход:**
- Разбиение на маленькие управляемые части
- Постепенный перенос данных/пользователей/функций
- Валидация на каждом этапе
- Значительное снижение рисков
- Возможность остановки и анализа

### Monitoring и Observability
**Visibility в процесс миграции:**
- Метрики выполнения миграций
- Алерты на аномалии
- Tracking состояния схемы
- Audit log всех изменений
- Performance impact мониторинг

### Automation и CI/CD
**Infrastructure as Code для БД:**
- Миграции в CI/CD pipeline
- Автоматическое выполнение в правильной последовательности
- Gating: тесты должны пройти перед продакшеном
- Unified deployment process

---

## Архитектурные Решения для Масштаба

### 1. Online Schema Change (OSC)
**Для больших таблиц:**
- Инструменты: pt-online-schema-change (Percona), gh-ost (GitHub)
- Создание теневой таблицы
- Постепенное копирование данных
- Триггеры для синхронизации изменений
- Атомарная подмена таблиц

### 2. Index Management
**Минимизация downtime:**
- CREATE INDEX CONCURRENTLY (PostgreSQL)
- ONLINE keyword (MySQL)
- Создание индексов вне пиковой нагрузки
- Мониторинг прогресса

### 3. Data Migration в Background
**Большие объемы данных:**
- Batch processing с rate limiting
- Приоритет живого трафика над миграцией
- Идемпотентные batch jobs
- Progress tracking и resumability
- Использование dead letter queues для ошибок

---

## Выбор Системы: Decision Matrix

| Критерий | Flyway | Liquibase | Alembic | Doctrine |
|----------|--------|-----------|---------|----------|
| **Простота** | ★★★★★ | ★★★☆☆ | ★★★★☆ | ★★★★☆ |
| **Гибкость** | ★★★☆☆ | ★★★★★ | ★★★☆☆ | ★★★☆☆ |
| **Performance** | ★★★★★ | ★★★★☆ | ★★★★☆ | ★★★★☆ |
| **Rollback** | ★★☆☆☆ (платно) | ★★★★★ | ★★★★☆ | ★★★★☆ |
| **Multi-DB** | ★★★☆☆ | ★★★★★ | ★★☆☆☆ | ★★☆☆☆ |
| **Enterprise** | ★★★★☆ | ★★★★★ | ★★★☆☆ | ★★★☆☆ |
| **Ecosystem** | Java/любой | Java/любой | Python | PHP |

---

## Современные Тренды 2025-2026

### 1. Schema-as-Code Movement
- Полная автоматизация схемы через код
- GitOps для баз данных
- Declarative infrastructure

### 2. AI-Assisted Migration Planning
- Анализ impact changes
- Автоматическое предложение rollback стратегий
- Оптимизация порядка миграций

### 3. Multi-Cloud Database Portability
- Vendor-agnostic миграции
- Абстракция различий между cloud providers
- Unified migration tooling

### 4. Real-Time Schema Evolution
- Streaming database changes
- Event-driven schema updates
- Reactive migration systems

### 5. Policy-as-Code для Миграций
- Автоматическая проверка compliance
- Security policies в CI/CD
- Custom rules для enterprise требований

---

## Критические Антипаттерны

### ❌ Не делайте:
- **Big Bang Migrations** - монолитные изменения вместо инкрементальных
- **Manual Migrations** - ручные изменения в обход версионирования
- **Skip Testing** - деплой в прод без staging валидации
- **Break Backward Compatibility** - удаление используемых структур
- **Ignore Rollback Plan** - отсутствие стратегии отката
- **Bundle Unrelated Changes** - смешивание разных логических изменений
- **Production-Only Scripts** - миграции существующие только в проде
- **Ignore Performance Impact** - игнорирование влияния на производительность

---

## Итоговые Рекомендации

**Для высоконагруженных систем:**
1. Liquibase для гибкости и enterprise features
2. Expand-Contract паттерн как стандарт
3. Обязательное автоматическое тестирование
4. CDC для критичных миграций

**Для быстрой разработки:**
1. Flyway для простоты и скорости
2. Backward compatibility как минимум
3. Feature flags для контроля
4. Staging environment обязателен

**Универсальные принципы:**
- Версионность схемы = версионность кода
- Автоматизация > ручная работа
- Тестирование > надежда
- Инкрементальность > big bang
- Мониторинг > слепой запуск
- Документированный rollback > авария

**Golden Rule:** Если миграция не может быть откачена безопасно - она не должна быть применена.
